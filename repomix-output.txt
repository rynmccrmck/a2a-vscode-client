This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-07-26T04:01:01.854Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  icons/
    a2a-logo.svg
  templates/
    chat.html
  A2AService.ts
  ChatProvider.ts
  extension.ts
  HttpClient.ts
.gitignore
CHANGELOG.md
LICENCE.txt
package.json
README.md
tsconfig.json

================================================================
Repository Files
================================================================

================
File: src/icons/a2a-logo.svg
================
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 36 36" fill="none">
  <path d="M8.7 14.725C8.51667 14.9083 8.28333 15 8 15C7.71667 15 7.475 14.9083 7.275 14.725C7.09167 14.525 7 14.2833 7 14C7 13.7167 7.09167 13.4833 7.275 13.3C7.475 13.1 7.71667 13 8 13C8.28333 13 8.51667 13.1 8.7 13.3C8.9 13.4833 9 13.7167 9 14C9 14.2833 8.9 14.525 8.7 14.725Z" fill="white"/>
  <path d="M14.7 14.725C14.5167 14.9083 14.2833 15 14 15C13.7167 15 13.475 14.9083 13.275 14.725C13.0917 14.525 13 14.2833 13 14C13 13.7167 13.0917 13.4833 13.275 13.3C13.475 13.1 13.7167 13 14 13C14.2833 13 14.5167 13.1 14.7 13.3C14.9 13.4833 15 13.7167 15 14C15 14.2833 14.9 14.525 14.7 14.725Z" fill="white"/>
  <path d="M22.7 14.725C22.5167 14.9083 22.2833 15 22 15C21.7167 15 21.475 14.9083 21.275 14.725C21.0917 14.525 21 14.2833 21 14C21 13.7167 21.0917 13.4833 21.275 13.3C21.475 13.1 21.7167 13 22 13C22.2833 13 22.5167 13.1 22.7 13.3C22.9 13.4833 23 13.7167 23 14C23 14.2833 22.9 14.525 22.7 14.725Z" fill="white"/>
  <path d="M28.7 14.725C28.5167 14.9083 28.2833 15 28 15C27.7167 15 27.475 14.9083 27.275 14.725C27.0917 14.525 27 14.2833 27 14C27 13.7167 27.0917 13.4833 27.275 13.3C27.475 13.1 27.7167 13 28 13C28.2833 13 28.5167 13.1 28.7 13.3C28.9 13.4833 29 13.7167 29 14C29 14.2833 28.9 14.525 28.7 14.725Z" fill="white"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M5 14C5 12.3431 6.34315 11 8 11H14C14.776 11 15.284 11.1537 15.64 11.3818C15.8589 10.794 16.1517 10.1709 16.555 9.59795C15.8797 9.21153 15.0386 9 14 9H8C5.23858 9 3 11.2386 3 14C3 16.7612 5.23759 19 7.99926 19H14C15.7634 19 16.9573 18.3902 17.7375 17.35C18.4228 16.4363 18.7148 15.266 18.9483 14.3299L18.9701 14.2425C19.2327 13.1924 19.4442 12.4077 19.8625 11.85C20.2073 11.3902 20.7634 11 22 11H28.0005C29.6572 11 31 12.343 31 14C31 15.6569 29.6569 17 28 17H22C21.224 17 20.716 16.8463 20.36 16.6182C20.1411 17.206 19.8483 17.8291 19.445 18.402C20.1203 18.7885 20.9614 19 22 19H28C30.7614 19 33 16.7614 33 14C33 11.2388 30.7621 9 28.0005 9H22C20.2366 9 19.0427 9.60979 18.2625 10.65C17.5772 11.5637 17.2852 12.734 17.0517 13.6701L17.0299 13.7575C16.7673 14.8076 16.5558 15.5923 16.1375 16.15C15.7927 16.6098 15.2366 17 14 17H7.99926C6.34265 17 5 15.6571 5 14Z" fill="white"/>
  <path d="M7 23.5C6.71667 23.5 6.475 23.4083 6.275 23.225C6.09167 23.025 6 22.7833 6 22.5C6 22.2167 6.09167 21.9833 6.275 21.8C6.475 21.6 6.71667 21.5 7 21.5H12C12.2833 21.5 12.5167 21.6 12.7 21.8C12.9 21.9833 13 22.2167 13 22.5C13 22.7833 12.9 23.025 12.7 23.225C12.5167 23.4083 12.2833 23.5 12 23.5H7ZM5 27.5C4.71667 27.5 4.475 27.4083 4.275 27.225C4.09167 27.025 4 26.7833 4 26.5C4 26.2167 4.09167 25.9833 4.275 25.8C4.475 25.6 4.71667 25.5 5 25.5H8C8.28333 25.5 8.51667 25.6 8.7 25.8C8.9 25.9833 9 26.2167 9 26.5C9 26.7833 8.9 27.025 8.7 27.225C8.51667 27.4083 8.28333 27.5 8 27.5H5ZM12 27.5C11.7167 27.5 11.475 27.4083 11.275 27.225C11.0917 27.025 11 26.7833 11 26.5C11 26.2167 11.0917 25.9833 11.275 25.8C11.475 25.6 11.7167 25.5 12 25.5H20C20.2833 25.5 20.5167 25.6 20.7 25.8C20.9 25.9833 21 26.2167 21 26.5C21 26.7833 20.9 27.025 20.7 27.225C20.5167 27.4083 20.2833 27.5 20 27.5H12ZM28 27.5C27.7167 27.5 27.475 27.4083 27.275 27.225C27.0917 27.025 27 26.7833 27 26.5C27 26.2167 27.0917 25.9833 27.275 25.8C27.475 25.6 27.7167 25.5 28 25.5H32C32.2833 25.5 32.5167 25.6 32.7 25.8C32.9 25.9833 33 26.2167 33 26.5C33 26.7833 32.9 27.025 32.7 27.225C32.5167 27.4083 32.2833 27.5 32 27.5H28ZM16 23.5C15.7167 23.5 15.475 23.4083 15.275 23.225C15.0917 23.025 15 22.7833 15 22.5C15 22.2167 15.0917 21.9833 15.275 21.8C15.475 21.6 15.7167 21.5 16 21.5C16.2833 21.5 16.5167 21.6 16.7 21.8C16.9 21.9833 17 22.2167 17 22.5C17 22.7833 16.9 23.025 16.7 23.225C16.5167 23.4083 16.2833 23.5 16 23.5ZM24 27.5C23.7167 27.5 23.475 27.4083 23.275 27.225C23.0917 27.025 23 26.7833 23 26.5C23 26.2167 23.0917 25.9833 23.275 25.8C23.475 25.6 23.7167 25.5 24 25.5C24.2833 25.5 24.5167 25.6 24.7 25.8C24.9 25.9833 25 26.2167 25 26.5C25 26.7833 24.9 27.025 24.7 27.225C24.5167 27.4083 24.2833 27.5 24 27.5Z" fill="white"/>
  <path d="M19.275 23.225C19.475 23.4083 19.7167 23.5 20 23.5H23C23.2833 23.5 23.5167 23.4083 23.7 23.225C23.9 23.025 24 22.7833 24 22.5C24 22.2167 23.9 21.9833 23.7 21.8C23.5167 21.6 23.2833 21.5 23 21.5H20C19.7167 21.5 19.475 21.6 19.275 21.8C19.0917 21.9833 19 22.2167 19 22.5C19 22.7833 19.0917 23.025 19.275 23.225Z" fill="white"/>
  <path d="M26.275 23.225C26.475 23.4083 26.7167 23.5 27 23.5H30C30.2833 23.5 30.5167 23.4083 30.7 23.225C30.9 23.025 31 22.7833 31 22.5C31 22.2167 30.9 21.9833 30.7 21.8C30.5167 21.6 30.2833 21.5 30 21.5H27C26.7167 21.5 26.475 21.6 26.275 21.8C26.0917 21.9833 26 22.2167 26 22.5C26 22.7833 26.0917 23.025 26.275 23.225Z" fill="white"/>
</svg>

================
File: src/templates/chat.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A2A Agent Chat</title>
    <style>
        body { 
            font-family: var(--vscode-font-family); 
            color: var(--vscode-foreground); 
            background-color: var(--vscode-editor-background); 
            padding: 10px; 
            margin: 0; 
        }
        .container { 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
            gap: 10px; 
        }
        .section { 
            border: 1px solid var(--vscode-widget-border); 
            border-radius: 4px; 
            padding: 10px; 
        }
        .status { 
            padding: 8px; 
            border-radius: 4px; 
            margin: 8px 0; 
            font-size: 12px; 
        }
        .status.success { 
            background-color: var(--vscode-testing-iconPassed); 
            color: white; 
        }
        .status.error { 
            background-color: var(--vscode-testing-iconFailed); 
            color: white; 
        }
        .chat-section { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
        }
        .messages { 
            flex: 1; 
            overflow-y: auto; 
            margin-bottom: 10px; 
            padding: 8px; 
            background-color: var(--vscode-input-background); 
            border-radius: 4px; 
            min-height: 200px; 
        }
        .message { 
            margin-bottom: 10px; 
            padding: 6px 10px; 
            border-radius: 6px; 
            max-width: 90%; 
            word-wrap: break-word;
        }
        .message.user { 
            background-color: var(--vscode-button-background); 
            color: var(--vscode-button-foreground); 
            margin-left: auto; 
        }
        .message.agent { 
            background-color: var(--vscode-textCodeBlock-background); 
            border: 1px solid var(--vscode-widget-border); 
        }
        .message.agent.streaming {
            border-left: 3px solid var(--vscode-progressBar-background);
            animation: pulse 1s infinite;
        }
        .message.status {
            background-color: var(--vscode-notifications-background);
            border: 1px solid var(--vscode-notifications-border);
            font-size: 11px;
            padding: 4px 8px;
            margin: 2px 0;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .message.status:hover {
            background-color: var(--vscode-list-hoverBackground);
        }
        .message.status .status-main {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .message.status .status-badge {
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
        }
        .message.status .status-badge.submitted {
            background-color: var(--vscode-button-secondaryBackground);
            color: var(--vscode-button-secondaryForeground);
        }
        .message.status .status-badge.working {
            background-color: var(--vscode-progressBar-background);
            color: white;
        }
        .message.status .status-badge.completed {
            background-color: var(--vscode-testing-iconPassed);
            color: white;
        }
        .message.status .status-badge.canceled {
            background-color: var(--vscode-testing-iconSkipped);
            color: white;
        }
        .message.status .status-badge.failed {
            background-color: var(--vscode-testing-iconFailed);
            color: white;
        }
        .message.status .status-badge.rejected {
            background-color: var(--vscode-testing-iconFailed);
            color: white;
        }
        .message.status .status-badge.auth-required {
            background-color: var(--vscode-testing-iconQueued);
            color: white;
        }
        .message.status .status-badge.unknown {
            background-color: var(--vscode-descriptionForeground);
            color: white;
        }
        .message.status .status-details {
            margin-top: 4px;
            padding-top: 4px;
            border-top: 1px solid var(--vscode-widget-border);
            font-family: monospace;
            font-size: 10px;
            color: var(--vscode-descriptionForeground);
            display: none;
        }
        .message.status.expanded .status-details {
            display: block;
        }
        .agent-info {
            margin-top: 8px;
            padding: 8px;
            background-color: var(--vscode-textCodeBlock-background);
            border-radius: 4px;
            border: 1px solid var(--vscode-widget-border);
            font-size: 11px;
            display: none;
        }
        .agent-info.visible {
            display: block;
        }
        .agent-info .agent-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-weight: bold;
        }
        .agent-info .agent-header .agent-name {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .agent-info .agent-header .connected-check {
            color: var(--vscode-testing-iconPassed);
            font-size: 14px;
        }
        .agent-info .agent-content {
            transition: all 0.3s ease;
        }
        .agent-info.collapsed .agent-content {
            display: none;
        }
        .agent-info .agent-description {
            color: var(--vscode-descriptionForeground);
            margin-bottom: 8px;
            font-style: italic;
            line-height: 1.3;
        }
        .agent-capabilities {
            display: flex;
            gap: 4px;
            margin-bottom: 6px;
        }
        .capability-badge {
            background-color: var(--vscode-button-secondaryBackground);
            color: var(--vscode-button-secondaryForeground);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 9px;
            font-weight: bold;
        }
        .agent-skills {
            margin-top: 6px;
        }
        .skill-item {
            background-color: var(--vscode-input-background);
            border: 1px solid var(--vscode-input-border);
            border-radius: 3px;
            padding: 4px 6px;
            margin: 2px 0;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .skill-item:hover {
            background-color: var(--vscode-list-hoverBackground);
        }
        .skill-name {
            font-weight: bold;
            font-size: 10px;
        }
        .skill-description {
            color: var(--vscode-descriptionForeground);
            font-size: 9px;
            margin-top: 2px;
        }
        .skill-examples {
            margin-top: 4px;
            padding-top: 4px;
            border-top: 1px solid var(--vscode-widget-border);
            display: none;
        }
        .skill-item.expanded .skill-examples {
            display: block;
        }
        .skill-example {
            background-color: var(--vscode-textCodeBlock-background);
            padding: 2px 4px;
            margin: 2px 0;
            border-radius: 2px;
            font-size: 8px;
            font-family: monospace;
            cursor: pointer;
            border: 1px solid transparent;
        }
        .skill-example:hover {
            border-color: var(--vscode-button-background);
        }
        .toggle-info {
            font-size: 9px;
            color: var(--vscode-button-background);
            cursor: pointer;
            text-decoration: underline;
        }
        .message.system { 
            background-color: var(--vscode-badge-background); 
            color: var(--vscode-badge-foreground); 
            font-style: italic; 
            text-align: center; 
            font-size: 12px; 
        }
        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        input { 
            width: 100%; 
            padding: 8px; 
            border: 1px solid var(--vscode-input-border); 
            border-radius: 4px; 
            background-color: var(--vscode-input-background); 
            color: var(--vscode-input-foreground); 
            margin: 5px 0; 
        }
        button { 
            padding: 8px 16px; 
            border: none; 
            border-radius: 4px; 
            background-color: var(--vscode-button-background); 
            color: var(--vscode-button-foreground); 
            cursor: pointer; 
            margin: 2px; 
        }
        button:hover { 
            background-color: var(--vscode-button-hoverBackground); 
        }
        button:disabled { 
            opacity: 0.5; 
            cursor: not-allowed; 
        }
        .input-row { 
            display: flex; 
            gap: 8px; 
            align-items: center; 
        }
        .input-row input { 
            flex: 1; 
            margin: 0; 
        }
        .session-info { 
            font-size: 11px; 
            color: var(--vscode-descriptionForeground); 
            margin-bottom: 8px; 
        }
        .toggle-group { 
            display: flex; 
            border: 1px solid var(--vscode-input-border); 
            border-radius: 4px; 
            overflow: hidden; 
            margin: 5px 0; 
        }
        .toggle-group button { 
            border-radius: 0; 
            margin: 0; 
            background: var(--vscode-input-background); 
            color: var(--vscode-input-foreground); 
        }
        .toggle-group button.active { 
            background: var(--vscode-button-background); 
            color: var(--vscode-button-foreground); 
        }
        pre { 
            background-color: var(--vscode-textCodeBlock-background); 
            padding: 8px; 
            border-radius: 4px; 
            overflow-x: auto; 
            font-size: 11px; 
            margin: 4px 0; 
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Agent Connection Section -->
        <div class="section">
            <h3>Agent Connection</h3>
            <div class="input-row">
                <input type="text" id="agentUrl" placeholder="Agent URL" value="http://localhost:10000">
                <button onclick="checkAgent()" id="checkBtn">Check Agent</button>
            </div>
            <div id="agentStatus"></div>
            <div id="agentInfo" class="agent-info"></div>
        </div>
        
            <!-- Chat Section -->
        <div class="section chat-section">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h3>Chat</h3>
                </div>
                <div>
                    <button onclick="newTask()" id="newTaskBtn" disabled>New Task</button>
                </div>
            </div>
            <div class="session-info">
                <strong>Task ID:</strong> <span id="taskId">None</span>
            </div>
            
            <!-- Streaming Toggle -->
            <div class="toggle-group">
                <button onclick="setStreaming(false)" id="sendBtn" class="active">Send</button>
                <button onclick="setStreaming(true)" id="streamBtn">Stream</button>
            </div>
            
            <div class="messages" id="messages">
                <div class="message system">Enter an agent URL above and click "Check Agent" to start!</div>
            </div>
            
            <div class="input-row">
                <input type="text" id="messageInput" placeholder="Type your message..." disabled>
                <button onclick="sendMessage()" id="sendMessageBtn" disabled>Send</button>
            </div>
        </div>
    </div>

    <script>
        const vscode = acquireVsCodeApi();
        let agentConnected = false;
        let currentAgentUrl = '';
        let useStreaming = false;
        let messageSequence = 0;
        let currentTaskId = null;
        let currentContextId = null;

        function checkAgent() {
            const url = document.getElementById('agentUrl').value.trim();
            if (!url) return;
            
            currentAgentUrl = url;
            document.getElementById('checkBtn').disabled = true;
            showStatus('Checking agent...', null);
            
            vscode.postMessage({ type: 'checkAgent', url: url });
        }

        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message || !agentConnected) return;
            
            addMessage(message, 'user');
            input.value = '';
            disableSendButton();
            
            // Reset message tracking for new interaction
            messageSequence = 0;
            
            vscode.postMessage({ 
                type: 'sendMessage', 
                url: currentAgentUrl, 
                message: message,
                useStreaming: useStreaming,
                taskId: currentTaskId,
                contextId: currentContextId
            });
        }

        function newTask() {
            currentTaskId = null;
            currentContextId = null;
            updateTaskDisplay();
            
            const messagesDiv = document.getElementById('messages');
            messagesDiv.innerHTML = '<div class="message system">ðŸ†• New task started - send a message to begin!</div>';
            
            addMessage('Task reset - ready for new conversation', 'system');
            
            // Re-enable send button
            enableSendButton();
        }

        function getTaskStatus() {
            if (!currentTaskId) {
                addMessage('No active task to check', 'system');
                return;
            }
            
            // Disable send button while checking status
            disableSendButton();
            
            vscode.postMessage({
                type: 'getTaskStatus',
                url: currentAgentUrl,
                taskId: currentTaskId
            });
        }

        function updateTaskDisplay() {
            console.log('Updating task display:', { taskId: currentTaskId });
            document.getElementById('taskId').textContent = currentTaskId || 'None';
        }

        function enableSendButton() {
            document.getElementById('sendMessageBtn').disabled = false;
        }

        function disableSendButton() {
            document.getElementById('sendMessageBtn').disabled = true;
        }

        function setStreaming(streaming) {
            useStreaming = streaming;
            document.getElementById('sendBtn').className = streaming ? '' : 'active';
            document.getElementById('streamBtn').className = streaming ? 'active' : '';
        }

        function showStatus(text, success) {
            const statusDiv = document.getElementById('agentStatus');
            
            if (success === false) {
                // Only show error status
                statusDiv.textContent = text;
                statusDiv.className = 'status error';
            } else {
                // Hide status for success (shown in agent info instead)
                statusDiv.textContent = '';
                statusDiv.className = '';
            }
        }

        function addMessage(text, sender, streaming = false, data = null) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ' + sender + (streaming ? ' streaming' : '');
            
            if (sender === 'agent' && typeof text === 'object') {
                const pre = document.createElement('pre');
                pre.textContent = JSON.stringify(text, null, 2);
                messageDiv.appendChild(pre);
            } else {
                messageDiv.textContent = text;
            }
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            return messageDiv;
        }

        function addStatusMessage(data) {
            // Only show status without message content for pure status updates
            if (data.statusOnly) {
                const messagesDiv = document.getElementById('messages');
                const statusDiv = document.createElement('div');
                statusDiv.className = 'message status';
                
                const mainDiv = document.createElement('div');
                mainDiv.className = 'status-main';
                
                const badge = document.createElement('span');
                badge.className = `status-badge ${data.status.state}`;
                badge.textContent = data.status.state.toUpperCase().replace('-', '-');
                mainDiv.appendChild(badge);
                
                if (data.status.final) {
                    const finalSpan = document.createElement('span');
                    finalSpan.textContent = 'âœ“ Final';
                    finalSpan.style.color = 'var(--vscode-testing-iconPassed)';
                    finalSpan.style.fontSize = '10px';
                    mainDiv.appendChild(finalSpan);
                }
                
                statusDiv.appendChild(mainDiv);
                
                const detailsDiv = document.createElement('div');
                detailsDiv.className = 'status-details';
                detailsDiv.innerHTML = `
                    <div>Task ID: ${data.status.taskId}</div>
                    <div>Context ID: ${data.status.contextId}</div>
                    <div>Timestamp: ${new Date(data.status.timestamp).toLocaleTimeString()}</div>
                `;
                statusDiv.appendChild(detailsDiv);
                
                statusDiv.addEventListener('click', () => {
                    statusDiv.classList.toggle('expanded');
                });
                
                messagesDiv.appendChild(statusDiv);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
        }

        function processStreamingData(data) {
            messageSequence++;
            
            // Update task info from streaming data if we don't have it yet
            if (data.status && !currentTaskId) {
                if (data.status.taskId) {
                    currentTaskId = data.status.taskId;
                    updateTaskDisplay();
                    console.log('Updated taskId from stream:', currentTaskId);
                }
                // We track contextId internally but don't display it
                if (data.status.contextId) {
                    currentContextId = data.status.contextId;
                }
            }
            
            if (data.statusOnly) {
                // Pure status update without message content
                addStatusMessage(data);
            } else if (data.text && data.text.trim()) {
                // Message with text content - treat each as separate message
                const messageDiv = addMessage(data.text, 'agent');
                
                // Add a small status indicator to the message if we have status info
                if (data.status) {
                    const statusBadge = document.createElement('span');
                    statusBadge.className = `status-badge ${data.status.state}`;
                    statusBadge.textContent = data.status.state.toUpperCase().replace('-', '-');
                    statusBadge.style.fontSize = '9px';
                    statusBadge.style.marginLeft = '8px';
                    statusBadge.style.opacity = '0.7';
                    messageDiv.appendChild(statusBadge);
                    
                    // Add click handler for message details
                    messageDiv.style.cursor = 'pointer';
                    messageDiv.title = 'Click for details';
                    messageDiv.addEventListener('click', () => {
                        const details = `
Task: ${data.status.taskId}
Context: ${data.status.contextId}
Message ID: ${data.messageId || 'N/A'}
Timestamp: ${new Date(data.status.timestamp).toLocaleString()}
State: ${data.status.state}
Final: ${data.status.final}
                        `.trim();
                        alert(details);
                    });
                }
            }
        }

        function showAgentInfo(agentCard) {
            const agentInfoDiv = document.getElementById('agentInfo');
            
            // Create capabilities badges
            const capabilities = [];
            if (agentCard.capabilities?.streaming) capabilities.push('Streaming');
            if (agentCard.capabilities?.pushNotifications) capabilities.push('Push Notifications');
            
            const capabilityBadges = capabilities.map(cap => 
                `<span class="capability-badge">${cap}</span>`
            ).join('');
            
            // Create skills list
            const skillsHtml = agentCard.skills?.map(skill => `
                <div class="skill-item" onclick="toggleSkill(this)">
                    <div class="skill-name">${skill.name}</div>
                    <div class="skill-description">${skill.description}</div>
                    <div class="skill-examples">
                        ${skill.examples?.map(example => 
                            `<div class="skill-example" onclick="useExample('${example.replace(/'/g, "\\'")}'); event.stopPropagation();">${example}</div>`
                        ).join('') || ''}
                    </div>
                </div>
            `).join('') || '<div style="color: var(--vscode-descriptionForeground);">No skills defined</div>';
            
            agentInfoDiv.innerHTML = `
                <div class="agent-header">
                    <div class="agent-name">
                        <span>${agentCard.name} v${agentCard.version}</span>
                        <span class="connected-check">âœ“</span>
                    </div>
                    <span class="toggle-info" onclick="toggleAgentInfo()">Hide Details</span>
                </div>
                <div class="agent-content">
                    <div class="agent-description">${agentCard.description || 'No description provided'}</div>
                    <div class="agent-capabilities">${capabilityBadges}</div>
                    <div class="agent-skills">
                        <strong>Skills (click to expand):</strong>
                        ${skillsHtml}
                    </div>
                </div>
            `;
            
            agentInfoDiv.classList.add('visible');
        }

        function toggleAgentInfo() {
            const agentInfoDiv = document.getElementById('agentInfo');
            const toggleText = agentInfoDiv.querySelector('.toggle-info');
            
            if (agentInfoDiv.classList.contains('collapsed')) {
                agentInfoDiv.classList.remove('collapsed');
                toggleText.textContent = 'Hide Details';
            } else {
                agentInfoDiv.classList.add('collapsed');
                toggleText.textContent = 'Show Details';
            }
        }

        function toggleSkill(skillElement) {
            skillElement.classList.toggle('expanded');
        }

        function useExample(example) {
            const messageInput = document.getElementById('messageInput');
            messageInput.value = example;
            messageInput.focus();
        }

        document.getElementById('messageInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        // Handle messages from extension
        window.addEventListener('message', event => {
            const message = event.data;
            console.log('Received message:', message);
            
            switch (message.type) {
                case 'taskInfo':
                    currentTaskId = message.taskId;
                    currentContextId = message.contextId;
                    updateTaskDisplay();
                    break;

                case 'agentChecked':
                    document.getElementById('checkBtn').disabled = false;
                    
                    if (message.success) {
                        agentConnected = true;
                        const agent = message.agent;
                        showStatus('', true); // Clear any error status
                        showAgentInfo(agent);
                        document.getElementById('messageInput').disabled = false;
                        document.getElementById('sendMessageBtn').disabled = false;
                        document.getElementById('newTaskBtn').disabled = false;
                        updateTaskDisplay();
                        // No longer adding "Connected to agent" message - shown in agent header
                    } else {
                        agentConnected = false;
                        showStatus('Connection failed: ' + message.error, false);
                        document.getElementById('agentInfo').classList.remove('visible');
                        document.getElementById('messageInput').disabled = true;
                        document.getElementById('sendMessageBtn').disabled = true;
                        document.getElementById('newTaskBtn').disabled = true;
                    }
                    break;

                case 'taskCreated':
                    currentTaskId = message.taskId;
                    currentContextId = message.contextId;
                    updateTaskDisplay();
                    addMessage(`ðŸŽ¯ Task created: ${message.taskId}`, 'system');
                    break;
                    
                case 'messageResponse':
                    if (message.streaming) {
                        console.log('Streaming chunk received:', message.data);
                        
                        // Filter out raw JSON data that shouldn't be displayed
                        if (message.data.raw || message.data.error) {
                            console.log('Skipping raw/error data:', message.data);
                            break;
                        }
                        
                        processStreamingData(message.data);
                        
                        // Check if this is the final streaming message
                        if (message.data.status?.final) {
                            console.log('Final streaming message detected - enabling send button');
                            enableSendButton();
                        }
                        break;
                    }

                    // Normal response after stream or single-shot
                    console.log('Non-streaming response received - enabling send button');
                    enableSendButton();
                    
                    if (message.success) {
                        // Handle task creation from response
                        if (message.data?.result?.id && message.data?.result?.kind === 'task') {
                            currentTaskId = message.data.result.id;
                            currentContextId = message.data.result.contextId;
                            updateTaskDisplay();
                            addMessage(`ðŸŽ¯ Task created: ${currentTaskId}`, 'system');
                        }
                        
                        // Also check streaming data for task info updates
                        if (message.data?.status?.taskId) {
                            if (message.data.status.taskId !== currentTaskId) {
                                currentTaskId = message.data.status.taskId;
                                updateTaskDisplay();
                                console.log('Updated taskId from non-streaming response:', currentTaskId);
                            }
                            // Track contextId internally but don't display
                            if (message.data.status.contextId) {
                                currentContextId = message.data.status.contextId;
                            }
                        }
                        
                        const result = message.data.result || message.data;
                        let responseText = '';
                        
                        if (result?.parts) {
                            result.parts.forEach(part => {
                                if (part.kind === 'text') {
                                    responseText += part.text;
                                }
                            });
                        } else if (result?.message?.parts) {
                            result.message.parts.forEach(part => {
                                if (part.kind === 'text') {
                                    responseText += part.text;
                                }
                            });
                        } else if (typeof result === 'string') {
                            responseText = result;
                        } else if (result?.kind !== 'task') {
                            responseText = JSON.stringify(result, null, 2);
                        }
                        
                        if (!message.streaming && responseText) {
                            addMessage(responseText || 'Empty response', 'agent');
                        }
                    } else {
                        addMessage('Error: ' + message.error, 'system');
                    }
                    break;

                case 'streamComplete':
                    console.log('Stream completed - re-enabling send button');
                    enableSendButton();
                    addMessage('ðŸ”„ Stream completed', 'system');
                    break;

                case 'error':
                    addMessage('Extension Error: ' + message.error, 'system');
                    enableSendButton();
                    break;
            }
        });
    </script>
</body>
</html>

================
File: src/A2AService.ts
================
import { HttpClient } from './HttpClient';

export class A2AService {
    private httpClient: HttpClient;
    private logger: (message: string, level?: 'INFO' | 'WARN' | 'ERROR') => void;

    constructor(
        httpClient: HttpClient, 
        logger: (message: string, level?: 'INFO' | 'WARN' | 'ERROR') => void
    ) {
        this.httpClient = httpClient;
        this.logger = logger;
    }

    public async checkAgent(agentUrl: string): Promise<any> {
        this.logger(`Checking agent at: ${agentUrl}`);
        
        const cardUrl = agentUrl.endsWith('/') ? 
            `${agentUrl}.well-known/agent.json` : 
            `${agentUrl}/.well-known/agent.json`;

        this.logger(`Fetching agent card from: ${cardUrl}`);
        
        try {
            const response = await this.httpClient.get(cardUrl);
            const agentCard = JSON.parse(response);
            
            this.logger(`Successfully connected to agent: ${agentCard.name} v${agentCard.version}`);
            return agentCard;
            
        } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            this.logger(`Failed to check agent: ${errorMsg}`, 'ERROR');
            throw error;
        }
    }

    public async sendMessage(
        agentUrl: string, 
        messageText: string, 
        useStreaming: boolean = false,
        taskId?: string,
        contextId?: string,
        onStream?: (data: any) => void
    ): Promise<any> {
        this.logger(`Sending message: "${messageText}" (streaming: ${useStreaming}, taskId: ${taskId || 'new'})`);
        
        const message: any = {
            kind: "message",
            role: "user",
            messageId: `msg-${Date.now()}`,
            parts: [{ kind: "text", text: messageText }]
        };

        if (taskId) {
            message.taskId = taskId;
            this.logger(`Including taskId in message: ${taskId}`);
        }
        if (contextId) {
            message.contextId = contextId;
            this.logger(`Including contextId in message: ${contextId}`);
        }

        const request = {
            id: `req-${Date.now()}`,
            jsonrpc: "2.0",
            method: useStreaming ? "message/stream" : "message/send",
            params: {
                message,
                metadata: { clientId: "vscode-client" }
            }
        };

        if (useStreaming && onStream) {
            this.logger('Starting streaming request...');
            
            try {
                let eventCount = 0;
                await this.httpClient.stream(
                    agentUrl,
                    {
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'text/event-stream'
                        },
                        body: JSON.stringify(request)
                    },
                    (eventData) => {
                        eventCount++;
                        this.logger(`Stream event ${eventCount}: ${eventData}`);
                        
                        try {
                            const parsed = JSON.parse(eventData);
                            
                            if (parsed.result?.kind === 'status-update') {
                                const status = parsed.result.status;
                                const message = status.message;
                                
                                const statusInfo = {
                                    state: status.state,
                                    timestamp: status.timestamp,
                                    final: parsed.result.final,
                                    taskId: parsed.result.taskId,
                                    contextId: parsed.result.contextId
                                };
                                
                                if (message?.parts) {
                                    const textParts = message.parts
                                        .filter((p: any) => p.kind === 'text')
                                        .map((p: any) => p.text);
                                    
                                    if (textParts.length > 0) {
                                        onStream({
                                            text: textParts.join(''),
                                            status: statusInfo,
                                            messageId: message.messageId,
                                            role: message.role
                                        });
                                    }
                                } else {
                                    onStream({
                                        text: '',
                                        status: statusInfo,
                                        statusOnly: true
                                    });
                                }
                            } else {
                                this.logger(`Unknown event format: ${JSON.stringify(parsed)}`, 'WARN');
                            }
                        } catch (parseError) {
                            this.logger(`Failed to parse stream data: ${parseError}`, 'ERROR');
                            onStream({ text: eventData, error: true });
                        }
                    }
                );
                
                this.logger(`Streaming completed successfully. Total events processed: ${eventCount}`);
                return { success: true };
                
            } catch (error) {
                const errorMsg = error instanceof Error ? error.message : String(error);
                this.logger(`Streaming failed: ${errorMsg}`, 'ERROR');
                throw error;
            }
        }

        const endpoint = agentUrl.endsWith('/') ? agentUrl : agentUrl + '/';
        
        try {
            const { response } = await this.httpClient.tryMultipleUrls([endpoint], {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify(request)
            });

            return JSON.parse(response);
        } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            this.logger(`Non-streaming request failed: ${errorMsg}`, 'ERROR');
            throw error;
        }
    }
}

================
File: src/ChatProvider.ts
================
import * as vscode from 'vscode';
import { A2AService } from './A2AService';

export class ChatProvider implements vscode.WebviewViewProvider {
    private a2aService: A2AService;
    private logger: (message: string, level?: 'INFO' | 'WARN' | 'ERROR') => void;

    constructor(
        private readonly extensionUri: vscode.Uri,
        a2aService: A2AService,
        logger: (message: string, level?: 'INFO' | 'WARN' | 'ERROR') => void
    ) {
        this.a2aService = a2aService;
        this.logger = logger;
    }

    public resolveWebviewView(
        webviewView: vscode.WebviewView,
        context: vscode.WebviewViewResolveContext,
        token: vscode.CancellationToken,
    ) {
        this.logger('Resolving A2A Chat webview');

        webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [this.extensionUri]
        };

        webviewView.webview.html = this.getWebviewHtml();

        webviewView.webview.onDidReceiveMessage(async (message) => {
            await this.handleWebviewMessage(webviewView, message);
        });
    }

    private async handleWebviewMessage(webviewView: vscode.WebviewView, message: any) {
        try {
            switch (message.type) {
                case 'checkAgent':
                    await this.handleCheckAgent(webviewView, message.url);
                    break;
                case 'sendMessage':
                    await this.handleSendMessage(webviewView, message.url, message.message, message.useStreaming, message.taskId, message.contextId);
                    break;
                default:
                    this.logger(`Unknown message type: ${message.type}`, 'WARN');
            }
        } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            this.logger(`Error handling webview message: ${errorMsg}`, 'ERROR');
            
            webviewView.webview.postMessage({
                type: 'error',
                error: errorMsg
            });
        }
    }

    private async handleCheckAgent(webviewView: vscode.WebviewView, agentUrl: string) {
        try {
            const agentCard = await this.a2aService.checkAgent(agentUrl);

            webviewView.webview.postMessage({
                type: 'agentChecked',
                success: true,
                agent: agentCard
            });
        } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            
            webviewView.webview.postMessage({
                type: 'agentChecked',
                success: false,
                error: errorMsg
            });
        }
    }

    private async handleSendMessage(
        webviewView: vscode.WebviewView, 
        agentUrl: string, 
        messageText: string, 
        useStreaming: boolean = false,
        taskId?: string,
        contextId?: string
    ) {
        try {
            if (useStreaming) {
                this.logger('Starting streaming message...');
                
                await this.a2aService.sendMessage(agentUrl, messageText, true, taskId, contextId, (chunk) => {
                    this.logger(`Forwarding stream chunk to UI: ${JSON.stringify(chunk)}`);
                    
                    webviewView.webview.postMessage({
                        type: 'messageResponse',
                        success: true,
                        streaming: true,
                        data: chunk
                    });
                });

                webviewView.webview.postMessage({
                    type: 'streamComplete',
                    success: true
                });

                this.logger('Streaming completed');
                return;
            }

            this.logger('Sending non-streaming message...');
            const result = await this.a2aService.sendMessage(agentUrl, messageText, false, taskId, contextId);
            
            webviewView.webview.postMessage({
                type: 'messageResponse',
                success: !result.error,
                data: result,
                streaming: false
            });

        } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            this.logger(`Message sending failed: ${errorMsg}`, 'ERROR');
            
            webviewView.webview.postMessage({
                type: 'messageResponse',
                success: false,
                error: errorMsg,
                streaming: useStreaming
            });
        }
    }

    private getWebviewHtml(): string {
        const fs = require('fs');
        const path = require('path');
        
        const templatePath = path.join(__dirname, '..', 'src', 'templates', 'chat.html');
        
        try {
            return fs.readFileSync(templatePath, 'utf8');
        } catch (error) {
            this.logger(`Could not load template file: ${error}`, 'WARN');
            return this.getFallbackHtml();
        }
    }

    private getFallbackHtml(): string {
        return `<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>A2A Chat Error</title>
    </head>
    <body>
        <h2>Template Loading Error</h2>
        <p>Could not load chat.html template.</p>
    </body>
    </html>`;
    }
}

================
File: src/extension.ts
================
import * as vscode from 'vscode';
import { ChatProvider } from './ChatProvider';
import { A2AService } from './A2AService';
import { HttpClient } from './HttpClient';

const outputChannel = vscode.window.createOutputChannel('A2A Chat');

function log(message: string, level: 'INFO' | 'WARN' | 'ERROR' = 'INFO') {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] [${level}] ${message}`;
    outputChannel.appendLine(logMessage);
    
    if (level === 'ERROR') {
        console.error(logMessage);
    } else if (level === 'WARN') {
        console.warn(logMessage);
    } else {
        console.log(logMessage);
    }
}

export function activate(context: vscode.ExtensionContext) {
    log('A2A Chat extension is now active!');
    outputChannel.show(true);

    const httpClient = new HttpClient();
    const a2aService = new A2AService(httpClient, log);
    const chatProvider = new ChatProvider(context.extensionUri, a2aService, log);

    context.subscriptions.push(
        vscode.window.registerWebviewViewProvider('a2a-chat.chatView', chatProvider)
    );

    const openChatCommand = vscode.commands.registerCommand('a2a-chat.openChat', () => {
        vscode.commands.executeCommand('workbench.view.extension.a2a-chat');
    });

    const viewAgentCardCommand = vscode.commands.registerCommand('a2a-chat.viewAgentCard', async () => {
        const url = await vscode.window.showInputBox({
            prompt: 'Enter agent URL',
            placeHolder: 'http://localhost:41241'
        });
        
        if (url) {
            const panel = vscode.window.createWebviewPanel(
                'a2aAgentCard',
                'A2A Agent Card',
                vscode.ViewColumn.One,
                { enableScripts: true }
            );
            
            panel.webview.html = `
                <html>
                    <body style="font-family: Arial, sans-serif; padding: 20px;">
                        <h1>Agent Card Viewer</h1>
                        <p>Loading agent card from: ${url}</p>
                        <iframe src="${url}/.well-known/agent.json" 
                                style="width: 100%; height: 80vh; border: 1px solid #ccc;">
                        </iframe>
                    </body>
                </html>
            `;
        }
    });

    context.subscriptions.push(openChatCommand, viewAgentCardCommand);
}

export function deactivate() {
    log('A2A Chat extension deactivated');
    outputChannel.dispose();
}

================
File: src/HttpClient.ts
================
export class HttpClient {
    
    async fetch(url: string, options?: {
        method?: string;
        headers?: Record<string, string>;
        body?: string;
    }): Promise<string> {
        const https = require('https');
        const http = require('http');

        return new Promise((resolve, reject) => {
            const isHttps = url.startsWith('https:');
            const client = isHttps ? https : http;
            const urlObj = new URL(url);

            const requestOptions = {
                hostname: urlObj.hostname,
                port: urlObj.port || (isHttps ? 443 : 80),
                path: urlObj.pathname + urlObj.search,
                method: options?.method || 'GET',
                headers: options?.headers || {}
            };

            const req = client.request(requestOptions, (res: any) => {
                let data = '';
                res.on('data', (chunk: any) => data += chunk);
                res.on('end', () => {
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                        resolve(data);
                    } else {
                        reject(new Error(`HTTP ${res.statusCode}: ${res.statusMessage}`));
                    }
                });
            });

            req.on('error', reject);
            
            if (options?.body) {
                req.write(options.body);
            }
            req.end();
        });
    }

    async get(url: string, headers?: Record<string, string>): Promise<string> {
        return this.fetch(url, { method: 'GET', headers });
    }

    async post(url: string, body: any, headers?: Record<string, string>): Promise<string> {
        const defaultHeaders = { 'Content-Type': 'application/json' };
        const mergedHeaders = { ...defaultHeaders, ...headers };
        
        return this.fetch(url, {
            method: 'POST',
            headers: mergedHeaders,
            body: typeof body === 'string' ? body : JSON.stringify(body)
        });
    }

    async stream(url: string, options: { headers?: Record<string, string>; body?: string }, onEvent: (event: string) => void): Promise<void> {
        const https = require('https');
        const http = require('http');

        return new Promise((resolve, reject) => {
            const isHttps = url.startsWith('https:');
            const client = isHttps ? https : http;
            const urlObj = new URL(url);

            const requestOptions = {
                hostname: urlObj.hostname,
                port: urlObj.port || (isHttps ? 443 : 80),
                path: urlObj.pathname + urlObj.search,
                method: 'POST',
                headers: {
                    'Accept': 'text/event-stream',
                    'Cache-Control': 'no-cache',
                    'Connection': 'keep-alive',
                    ...options.headers
                }
            };

            const req = client.request(requestOptions, (res: any) => {
                if (res.statusCode !== 200) {
                    reject(new Error(`HTTP ${res.statusCode}: ${res.statusMessage}`));
                    return;
                }

                res.setEncoding('utf8');
                let buffer = '';

                res.on('data', (chunk: string) => {
                    buffer += chunk;

                    const dataEvents = chunk.split('data: ').filter(part => part.trim());
                    
                    dataEvents.forEach(eventData => {
                        eventData = eventData.trim();
                        if (!eventData || eventData === '[DONE]') return;
                        
                        eventData = eventData.replace(/\s*data:\s*$/, '');
                        
                        if (eventData.startsWith('{') && eventData.includes('}')) {
                            const jsonMatch = eventData.match(/^(\{.*\})/);
                            if (jsonMatch) {
                                try {
                                    onEvent(jsonMatch[1]);
                                } catch (error) {
                                    console.error('Error in onEvent callback:', error);
                                }
                            }
                        }
                    });
                });

                res.on('end', () => {
                    if (buffer.trim()) {
                        try {
                            onEvent(buffer.trim());
                        } catch (error) {
                            console.error('Error processing final buffer:', error);
                        }
                    }
                    resolve();
                });

                res.on('error', reject);
            });

            req.on('error', reject);

            if (options.body) {
                req.write(options.body);
            }
            req.end();
        });
    }

    async tryMultipleUrls(urls: string[], options?: {
        method?: string;
        headers?: Record<string, string>;
        body?: string;
    }): Promise<{ url: string; response: string }> {
        let lastError: Error | null = null;

        for (const url of urls) {
            try {
                const response = await this.fetch(url, options);
                return { url, response };
            } catch (error) {
                lastError = error instanceof Error ? error : new Error(String(error));
                continue;
            }
        }

        throw lastError || new Error('All URLs failed');
    }
}

================
File: .gitignore
================
# Compiled output
out/
*.vsix

# Dependencies
node_modules/

# IDE files
.vscode/settings.json
.vscode/launch.json
.vscode/extensions.json

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids/
*.pid
*.seed
*.pid.lock

# Temporary folders
tmp/
temp/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Coverage directory used by tools like istanbul
coverage/

# nyc test coverage
.nyc_output

# Package manager
package-lock.json
yarn.lock

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

================
File: CHANGELOG.md
================
# Change Log

## [0.1.0] - 2025-08-01

### Added

- Initial release
- A2A agent connection and chat
- Agent card viewer
- Basic error handling and logging

================
File: LICENCE.txt
================
MIT License

Copyright (c) 2025 Your Name

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "a2a-vscode-client",
  "displayName": "A2A Agent Chat",
  "description": "Connect & Debug Agent-to-Agent (A2A) protocol compatible agents directly in VSCode",
  "version": "0.1.0",
  "publisher": "rynmccrmck",
  "author": "Ryan McCormack",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/rynmccrmck/a2a-vscode-client.git"
  },
  "bugs": {
    "url": "https://github.com/rynmccrmck/a2a-vscode-client/issues"
  },
  "homepage": "https://github.com/rynmccrmck/a2a-vscode-client#readme",
  "keywords": [
    "a2a",
    "agent",
    "chat",
    "ai"
  ],
  "engines": {
    "vscode": "^1.74.0"
  },
  "categories": [
    "Other"
  ],
  "activationEvents": [],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "a2a-vscode-client.openChat",
        "title": "Open A2A Chat",
        "category": "A2A",
        "icon": "$(comment-discussion)"
      },
      {
        "command": "a2a-vscode-client.viewAgentCard",
        "title": "View Agent Card",
        "category": "A2A",
        "icon": "$(info)"
      }
    ],
    "viewsContainers": {
      "activitybar": [
        {
          "id": "a2a-vscode-client",
          "title": "A2A",
          "icon": "$(comment-discussion)"
        }
      ]
    },
    "views": {
      "a2a-vscode-client": [
        {
          "id": "a2a-vscode-client.chatView",
          "name": "Agent Chat",
          "type": "webview",
          "contextualTitle": "A2A Agent Chat"
        }
      ]
    },
    "configuration": {
      "title": "A2A Client",
      "properties": {
        "a2a-vscode-client.agentUrl": {
          "type": "string",
          "default": "http://localhost:10000",
          "description": "Default A2A Agent base URL",
          "scope": "window"
        },
        "a2a-vscode-client.enableLogging": {
          "type": "boolean",
          "default": true,
          "description": "Enable detailed logging in the Output panel",
          "scope": "window"
        }
      }
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./",
    "pretest": "npm run compile && npm run lint",
    "lint": "eslint src --ext ts",
    "test": "node ./out/test/runTest.js",
    "package": "vsce package",
    "publish": "vsce publish"
  },
  "devDependencies": {
    "@types/vscode": "^1.74.0",
    "@types/node": "16.x",
    "@typescript-eslint/eslint-plugin": "^5.45.0",
    "@typescript-eslint/parser": "^5.45.0",
    "eslint": "^8.28.0",
    "typescript": "^4.9.4",
    "vsce": "^2.15.0"
  },
  "dependencies": {}
}

================
File: README.md
================
# A2A Agent Chat for VSCode

A Visual Studio Code extension that enables debugging Agent-to-Agent (A2A) protocol compatible agents directly within your development environment.

![A2A Chat Extension](https://img.shields.io/badge/VSCode-Extension-blue)
![License](https://img.shields.io/badge/license-MIT-green)

## âœ¨ Features

- ðŸ¤– **Agent Discovery**: Automatically discover and connect to A2A-compatible agents
- ðŸ’¬ **Real-time Chat**: Interactive chat interface with streaming support
- ðŸ” **Agent Inspection**: View agent capabilities, skills, and metadata
- ðŸŽ¯ **Task Management**: Create and manage conversation tasks with proper context
- ðŸŒŠ **Streaming Support**: Real-time message streaming for responsive interactions
- ðŸ“‹ **Rich UI**: Native VSCode theming with expandable agent information

## ðŸš€ Quick Start

1. **Install the Extension**

   - Download from VSCode Marketplace (coming soon) or install from VSIX
   - Or clone and build locally

2. **Connect to an Agent**

   - Open the A2A Chat panel from the activity bar
   - Enter your agent URL (e.g., `http://localhost:10000`)
   - Click "Check Agent" to establish connection

3. **Start Chatting**
   - Type your message in the input field
   - Choose between single-shot or streaming responses
   - View agent capabilities and suggested prompts

## ðŸ“‹ Requirements

- **VSCode**: Version 1.74.0 or higher
- **A2A Agent**: A running agent that implements the A2A protocol
- **Network Access**: HTTP/HTTPS connectivity to your agent

## ðŸ”§ Installation

### From Marketplace

```bash
# Coming soon - install directly from VSCode marketplace
code --install-extension a2a-chat
```

### Manual Installation

```bash
# Clone the repository
git clone https://github.com/rynmccrmck/a2a-chat-vscode.git
cd a2a-chat-vscode

# Install dependencies and compile
npm install
npm run compile

# Package the extension (optional)
npm install -g vsce
vsce package
```

## ðŸŽ¯ Usage

### Basic Chat

1. Open the A2A Chat view from the sidebar
2. Enter your agent's base URL
3. Click "Check Agent" to verify connection
4. Start chatting with your agent

### Agent Card

The extension automatically fetches agent metadata from the `/.well-known/agent.json` endpoint to display:

- Agent name and version
- Available capabilities (streaming, push notifications)
- Skill definitions with examples
- Connection status

## âš™ï¸ Configuration

Configure the default agent url for the extension through VSCode settings:

```json
{
  "a2a-chat.agentUrl": "http://localhost:10000"
}
```

## ðŸ—ï¸ Architecture

The extension is built with clean separation of concerns:

- **`extension.ts`**: Entry point and dependency injection
- **`ChatProvider.ts`**: VSCode webview UI management
- **`A2AService.ts`**: A2A protocol implementation
- **`HttpClient.ts`**: HTTP communication layer
- **`templates/chat.html`**: Rich web-based chat interface

## ðŸ¤ Contributing

We welcome contributions! Please see our contributing guidelines:

1. Fork the repository
2. Create a feature branch: `git checkout -b feature/amazing-feature`
3. Commit your changes: `git commit -m 'Add amazing feature'`
4. Push to the branch: `git push origin feature/amazing-feature`
5. Open a Pull Request

### Development Setup

```bash
# Clone and setup
git clone https://github.com/yourusername/a2a-chat-vscode.git
cd a2a-chat-vscode
npm install

# Start development
npm run compile  # Compile in watch mode
# Press F5 in VSCode to launch Extension Development Host
```

## ðŸ“ A2A Protocol Support

This extension implements the Agent-to-Agent protocol including:

- Agent discovery via `.well-known/agent.json`
- Message sending with `message/send` method
- Streaming responses via `message/stream` method
- Task management
- Status updates and error handling

## ðŸ› Troubleshooting

### Common Issues

**Connection Failed**

- Verify your agent is running and accessible
- Check the agent URL format (include protocol: `http://` or `https://`)
- Ensure the agent implements the A2A protocol correctly

**Streaming Not Working**

- Verify your agent supports streaming (`capabilities.streaming: true`)
- Check network connectivity and firewall settings
- Try switching to single-shot mode as fallback

**Agent Card Not Loading**

- Ensure `/.well-known/agent.json` endpoint is available
- Verify JSON format matches A2A specification
- Check VSCode Developer Console for detailed errors

## ðŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](LICENCE.txt) file for details.

## ðŸ”— Related Projects

- [A2A Protocol Specification](https://github.com/a2aproject/A2A)
- [A2A SDK JS](https://github.com/a2aproject/a2a-js)
- [A2A SDK Python](https://github.com/a2aproject/a2a-python)

## ðŸ“ž Support

- Create an issue on GitHub for bugs and feature requests
- Check the VSCode Output panel (A2A Chat) for detailed logs
- Join our community discussions

---

================
File: tsconfig.json
================
{
    "compilerOptions": {
        "module": "commonjs",
        "target": "ES2020",
        "outDir": "out",
        "lib": [
            "ES2020"
        ],
        "sourceMap": true,
        "rootDir": "src",
        "strict": true
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        ".vscode-test"
    ]
}
